    global DPYCURS
    global DPYCLRA
    global DPYCLRL
    global DPYDELL
    global DPYINIT
    global DPYINSL
    global DPYPRNA
    global DPYPRNU
    global DPYFLSH

    extern INTREAD

    maclib constants
    maclib z180

	cseg

DPYINIT:
    ld de, 0x0a60       ; cursor 1 start
    call set_6544_reg
    ld de, 0x0bff       ; cursor 1 end
    call set_6544_reg
    ld de, 0x2100       ; no padding between video memory rows
    call set_6544_reg
    ld de, 0x200e
    ret

set_6544_reg:
    out0 (VIDEO_ADDR), d
    nop
    out0 (VIDEO_DATA), e
    ret

; C = char; DE = (y, x)
DPYPRNA:
    call dirty_row

    ; Convert ASCII value
    ld a, c
    sub 0x20
    ld hl, character_map_table
    adda16 h, l
    ld c, (hl)              ; screencode

    ; Write
    call calc_backbuffer_address
    ld (hl), c
    ret

; Given a cursor location in de, calculates the address in hl.
calc_backbuffer_address:
    ; Calculate line address
    ld hl, back_buffer_address_table
    ld a, d
    add a
    adda16 h, l             ; (address) -> hl

    ld a, (hl)
    inc hl
    ld h, (hl)
    ld l, a                 ; address -> hl

    ; Calculate address of cursor
    ld a, e
    adda16 h, l
    ret

; HL = char; DE = (y, x)
DPYPRNU:
    call dirty_row
    ret

; On entry, D = y. On exit, HL is the dirty byte. Corrupts A.
dirty_row:
    ld hl, dirty_buffer
    ld a, d
    adda16 h, l
    ld (hl), 1
    ret

; On entry: DE = (y, x)
DPYCURS:
    ; Calculate video memory line address
    ld hl, video_memory_address_table
    ld a, d
    add a
    adda16 h, l             ; [address] -> hl

    ld a, (hl)
    inc hl
    ld h, (hl)
    ld l, a                 ; address -> hl

    ; Calculate address of cursor
    ld a, e
    adda16 h, l             ; address -> hl

    ld a, 15
    out0 (VIDEO_ADDR), a
    nop
    out0 (VIDEO_DATA), l
    ld a, 14
    out0 (VIDEO_ADDR), a
    ld a, h
    and $0f
    out0 (VIDEO_DATA), a

    ret

dirty_to_end_of_screen:
    call dirty_row          ; dirty byte -> hl

    ld a, SCREEN_HEIGHT
    sub d                   ; number of lines to dirty

    ld b, a
    ld a, 1
.1
    ld (hl), a
    inc hl
    djnz .1
    ret

; On entry: DE = (y, x)
DPYDELL:
    ld a, SCREEN_HEIGHT-1
    cp d
    jr z, blank_last_line   ; on the last line?

    call dirty_to_end_of_screen

    ld e, 0                 ; x = 0
    call calc_backbuffer_address ; line address -> hl

    ex de, hl               ; line address -> de
    ld hl, back_buffer_end - SCREEN_WIDTH
    ccf
    sbc hl, de
    ld b, h
    ld c, l                 ; amount to copy -> bc

    ld h, d
    ld l, e
    ld a, SCREEN_WIDTH
    adda16 h, l             ; line+1 -> hl, line -> de
    ldir                    ; [hl++] -> [de++]

blank_last_line:
    ld hl, back_buffer + (SCREEN_HEIGHT-1)*SCREEN_WIDTH
    ld de, back_buffer + (SCREEN_HEIGHT-1)*SCREEN_WIDTH + 1
    ld bc, SCREEN_WIDTH - 1
    ld (hl), ' '
    ldir                    ; [hl++] -> [de++]

    ld a, 1
    ld (dirty_buffer + SCREEN_HEIGHT - 1), a
    ret

; On entry: DE = (y, x)
DPYINSL:
    ld a, SCREEN_HEIGHT-1
    cp d
    jr z, blank_last_line   ; on the last line?

    call dirty_to_end_of_screen

    ld e, 0                 ; x = 0
    call calc_backbuffer_address ; line address -> hl
    push hl

    ex de, hl               ; line address -> de
    ld hl, back_buffer_end - SCREEN_WIDTH
    ccf
    sbc hl, de
    ld b, h
    ld c, l                 ; amount to copy -> bc

    ld hl, back_buffer + (SCREEN_HEIGHT-2)*SCREEN_WIDTH + (SCREEN_WIDTH-1)
    ld de, back_buffer + (SCREEN_HEIGHT-1)*SCREEN_WIDTH + (SCREEN_WIDTH-1)
    lddr                    ; [hl--] -> [de--]

    pop hl
    jr clear_line_in_hl

; On entry: DE = (y, x)
DPYCLRL:
    call dirty_row

    ld e, 0                 ; x = 0
    call calc_backbuffer_address

clear_line_in_hl:
    ld d, h
    ld e, l
    inc de
    ld (hl), ' '
    ld bc, SCREEN_WIDTH - 1
    ldir                    ; [hl] -> [de]

    ret

; Clears rows d (inclusive) to e (exclusive).
DPYCLRA:
    ld a, d
    cp e
    ret z                   ; do nothing if nothing to do

    ; Are we clearing the entire screen?

    ld hl, SCREEN_HEIGHT    ; 0 -> h, SCREEN_HEIGHT -> l
    ccf
    sbc hl, de
    jr z, DPYCLRS           ; use optimised routine

    ; Set dirty bits.

    ld a, d
    ld hl, dirty_buffer
    adda16 h, l             ; get dirty buffer address of first line

    ld a, d                 ; first row -> a
.1
    ld (hl), 1
    inc hl
    inc a
    cp e
    jr nz, .1

    ; Clear the actual screen area.

    ld a, e
    add a                   ; *2
    ld hl, back_buffer_address_table
    adda16 h, l
    ld a, (hl)
    inc hl
    ld h, (hl)
    ld l, a                 ; address of last exclusive row -> hl
    ex de, hl               ; address of last exclusive row -> de, range -> hl

    ld a, h
    add a                   ; *2
    ld hl, back_buffer_address_table
    adda16 h, l
    ld a, (hl)
    inc hl
    ld h, (hl)
    ld l, a                 ; address of first row -> hl

    ex de, hl               ; first -> de, last -> hl
    ccf
    sbc hl, de              ; hl -> number of bytes
    dec hl                  ; hl -> number of bytes - 1
    ld b, h
    ld c, l                 ; bc -> number of bytes - 1

    ld h, d
    ld l, e                 ; first -> hl, de
    inc de                  ; first+1 byte -> de
    
    ld (hl), ' '
    ldir

    ret

; Clears the entire screen.
DPYCLRS:
    ; Set all dirty bits.

    ld hl, dirty_buffer
    ld de, dirty_buffer+1
    ld bc, SCREEN_HEIGHT-1
    ld (hl), 1
    ldir

    ; Clear the screen itself.

    ld hl, back_buffer
    ld de, back_buffer+1
    ld bc, SCREEN_WIDTH*SCREEN_HEIGHT - 1
    ld (hl), ' '
    ldir

    ret

; Flushes the backbuffer to the frontbuffer, if safe.
DPYFLSH:
    ld hl, old_blanking
    ld c, (hl)              ; load old blanking state

    ld a, 31
    out0 (VIDEO_ADDR), a
    nop
    in0 a, (VIDEO_DATA)
    and 0x02
    ld (hl), a              ; save blanking state

    ret z                   ; return if not in blanking period
    ld a, c
    or a
    ret nz                  ; return if we _were_ in blanking period

    ld a, 0x02              ; physical address = 0x020000 + back_buffer
    out0 (SAR0B), a
    ld a, 0x01              ; physical address = 0x011000
    out0 (DAR0B), a

    ld a, 0x02
    out0 (DMODE), a
    ld a, 0x40
    out0 (DCNTL), a

    ld b, UPDATE_ROWS       ; number of rows left to update
redraw macro ?skip
        ld hl, dirty_buffer + line_no
        ld a, (hl)
        or a
        jr z, ?skip

        dec (hl)            ; reset dirty bit

        ld de, back_buffer + line_no*SCREEN_WIDTH
        out0 (SAR0H), d
        out0 (SAR0L), e

        ld de, line_no*SCREEN_STRIDE + 0x1000
        out0 (DAR0H), d
        out0 (DAR0L), e

        ld de, SCREEN_WIDTH
        out0 (BCR0H), d
        out0 (BCR0L), e

        ld a, 0x40
        out0 (DSTAT), a

        dec b               ; drawn a row
        ret z
    ?skip:
    endm

    line_no = 0
    rept SCREEN_HEIGHT
        redraw
        line_no = line_no + 1
    endm

    ret

; Maps from ASCII (minus $20) to the Brother character set.

character_map_table:
    db ' ', '!', '"', '#', '$', '%', '&', $27
    db '(', ')', '*', '+', ',', '-', '.', '/'
    db '0', '1', '2', '3', '4', '5', '6', '7'
    db '8', '9', ':', ';', '<', '=', '>', '?'
    db '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G'
    db 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O'
    db 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W'
    db 'X', 'Y', 'Z', '[', $eb, ']', $8b, '_'
    db $8d, 'a', 'b', 'c', 'd', 'e', 'f', 'g'
    db 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o'
    db 'p', 'q', 'r', 's', 't', 'u', 'v', 'w'
    db 'x', 'y', 'z', $cc, $9b, $cd, $8f, $0d

back_buffer_address_table:
    line_no = 0
    rept SCREEN_HEIGHT + 1
        dw back_buffer + line_no*SCREEN_WIDTH
        line_no = line_no + 1
    endm

video_memory_address_table:
    line_no = 0
    rept SCREEN_HEIGHT
        dw VIDEORAM_BASE + line_no*SCREEN_STRIDE + 0x1000
        line_no = line_no + 1
    endm

    dseg
back_buffer: ds SCREEN_WIDTH * SCREEN_HEIGHT
back_buffer_end:
dirty_buffer: ds SCREEN_HEIGHT
old_blanking: db 0

; vim: ts=4 sw=4 et ft=asm

